import { Express } from "express";
import Anthropic from "@anthropic-ai/sdk";

// Initialize Anthropic client
const anthropic = new Anthropic({
  apiKey: process.env.ANTHROPIC_API_KEY,
});

// Types for different analysis requests
interface AnalysisRequest {
  type: "purpose-interpretation" | "future-path" | "transformation-summary";
  data: Record<string, any>;
  userId?: string;
}

interface AnalysisResponse {
  success: boolean;
  analysis?: string;
  structured?: Record<string, any>;
  error?: string;
}

// System prompts for different analysis types
const systemPrompts = {
  "purpose-interpretation": `You are a compassionate life transformation coach analyzing a user's reflections from the "Understanding Your Path" self-discovery framework. The framework has 9 modules covering: Uncommon Beginnings, The Thirst Quotient, Dungeon Discoveries, Clues of Vision, Attitude that Opens Doors, Purpose Indicators, The Day of One Thing, Life's Interruptions, and Connecting the Dots.

Analyze their responses across THREE dimensions:

1. **Personal Development**: Identity, values, resilience, emotional growth, self-awareness, relationships
2. **Professional Development**: Career direction, skills, leadership potential, workplace contributions, professional growth
3. **Spiritual Development**: Purpose, meaning, connection to something greater, inner peace, legacy, faith journey

For each dimension, provide:
- 2-3 Key themes identified from their specific words
- 1-2 Strengths revealed
- 1-2 Growth opportunities
- 1 Specific actionable next step

Also provide:
- An overall "Purpose Statement" synthesis (2-3 sentences capturing their unique purpose)
- "Connecting the Dots" insight showing how their experiences link together

IMPORTANT: 
- Base your analysis ONLY on what the user has actually written
- Quote or reference their specific words when possible
- Be encouraging but honest
- If they haven't provided much content, acknowledge this and encourage deeper reflection
- Respond in JSON format`,

  "future-path": `You are a strategic life coach and futurist helping someone envision their transformation journey. Based on their self-assessment data (skills, preferences, resources, time use patterns, and subconscious drivers), provide personalized guidance.

Analyze their data and provide insights for these areas:

1. **Church Ministry & Spirituality**: How their profile aligns with faith-based service
2. **Business Development**: Entrepreneurial or career opportunities matching their strengths
3. **Technology & AI**: How they can leverage or adapt to technological changes
4. **Social Media & Community**: Their potential for building networks and influence
5. **Higher Education & Learning**: Continuous learning paths suited to them

For each area, provide:
- A personalized insight (2-3 sentences) based on THEIR specific data
- One concrete recommendation

Also provide:
- A "Transformation Archetype" label (e.g., "Restorative Leader", "Creative Innovator", "Community Builder")
- 3 Strategic Next Steps (Immediate, Short-term, Long-term)

Tailor insights based on persona if provided (student, professional, entrepreneur, retiree, veteran).

IMPORTANT:
- Reference their specific quiz answers and selections
- Be concrete and actionable, not generic
- Respond in JSON format`,

  "transformation-summary": `You are synthesizing a user's complete transformation journey into an actionable blueprint. You have access to their:
- Purpose reflections (Step 1)
- Change analysis results (Step 2) 
- Focus clarifications (Step 3)

Create a comprehensive summary that includes:

1. **Purpose Synthesis**: Their core purpose in 2-3 sentences
2. **Strengths Profile**: Top 5 strengths identified across all data
3. **Growth Areas**: 3 key areas for development
4. **Strategic Recommendation**: Primary transformation path recommendation
5. **90-Day Action Plan**: 
   - Week 1-2: Immediate actions
   - Month 1: Short-term goals
   - Month 2-3: Building momentum
6. **Success Metrics**: How they'll know they're on track

IMPORTANT:
- Synthesize across ALL their data, finding patterns
- Be specific and actionable
- Include encouragement but maintain honesty
- Respond in JSON format`
};

// Helper to format user data into prompt content
function formatDataForPrompt(type: AnalysisRequest["type"], data: Record<string, any>): string {
  switch (type) {
    case "purpose-interpretation":
      return formatPurposeData(data);
    case "future-path":
      return formatFuturePathData(data);
    case "transformation-summary":
      return formatSummaryData(data);
    default:
      return JSON.stringify(data, null, 2);
  }
}

function formatPurposeData(data: Record<string, any>): string {
  const { reflections, modules } = data;

  if (!reflections || Object.keys(reflections).length === 0) {
    return "The user has not yet provided any reflections. Please encourage them to complete the reflection modules.";
  }

  let formatted = "## User's Purpose Reflections\n\n";

  // Group by module
  const moduleAnswers: Record<number, { question: string; answer: string }[]> = {};

  for (const [key, answer] of Object.entries(reflections)) {
    if (!answer || (answer as string).trim().length === 0) continue;

    const [moduleId, questionIndex] = key.split("-").map(Number);
    if (!moduleAnswers[moduleId]) {
      moduleAnswers[moduleId] = [];
    }

    const module = modules?.find((m: any) => m.id === moduleId);
    const question = module?.questions?.[questionIndex] || `Question ${questionIndex + 1}`;

    moduleAnswers[moduleId].push({
      question,
      answer: answer as string
    });
  }

  for (const [moduleId, answers] of Object.entries(moduleAnswers)) {
    const module = modules?.find((m: any) => m.id === Number(moduleId));
    formatted += `### Module ${moduleId}: ${module?.title || "Unknown"}\n`;
    formatted += `*${module?.statement || ""}*\n\n`;

    for (const { question, answer } of answers) {
      formatted += `**Q: ${question}**\n`;
      formatted += `A: ${answer}\n\n`;
    }
  }

  return formatted;
}

function formatFuturePathData(data: Record<string, any>): string {
  const {
    subconsciousAnswers,
    preferenceAnswers,
    timeUseAnswers,
    skillsChecked,
    resourcesChecked,
    successChecked,
    persona
  } = data;

  let formatted = "## User's Transformation Analysis Data\n\n";

  // Subconscious patterns
  if (subconsciousAnswers && Object.keys(subconsciousAnswers).length > 0) {
    let subCount = 0;
    let conCount = 0;
    Object.values(subconsciousAnswers).forEach((val: any) => {
      if (val?.startsWith("SL")) subCount++;
      if (val?.startsWith("CL")) conCount++;
    });
    formatted += `### Decision-Making Pattern\n`;
    formatted += `- Impulsive/Emotional responses: ${subCount}\n`;
    formatted += `- Logical/Analytical responses: ${conCount}\n`;
    formatted += `- Tendency: ${subCount > conCount ? "More intuitive/emotional decision-maker" : "More logical/analytical decision-maker"}\n\n`;
  }

  // Work preferences
  if (preferenceAnswers && Object.keys(preferenceAnswers).length > 0) {
    const counts: Record<string, number> = { People: 0, Things: 0, Data: 0, Mixed: 0 };
    Object.values(preferenceAnswers).forEach((val: any) => {
      if (val in counts) counts[val]++;
    });
    formatted += `### Work Style Preferences\n`;
    formatted += `- People-oriented: ${counts.People}\n`;
    formatted += `- Things-oriented: ${counts.Things}\n`;
    formatted += `- Data-oriented: ${counts.Data}\n`;
    formatted += `- Mixed/Flexible: ${counts.Mixed}\n`;
    const dominant = Object.entries(counts).sort((a, b) => b[1] - a[1])[0];
    formatted += `- Primary preference: ${dominant[0]}\n\n`;
  }

  // Time use
  if (timeUseAnswers && Object.keys(timeUseAnswers).length > 0) {
    const counts: Record<string, number> = { A: 0, B: 0, C: 0, D: 0 };
    Object.values(timeUseAnswers).forEach((val: any) => {
      if (val in counts) counts[val]++;
    });
    const typeLabels: Record<string, string> = {
      A: "Highly Disciplined & Self-Driven",
      B: "Independent Learner",
      C: "Relaxation Focused",
      D: "Socially Connected"
    };
    const dominant = Object.entries(counts).sort((a, b) => b[1] - a[1])[0];
    formatted += `### Time Use Pattern\n`;
    formatted += `- Type: ${typeLabels[dominant[0]] || "Mixed"}\n\n`;
  }

  // Skills
  if (skillsChecked && skillsChecked.length > 0) {
    formatted += `### Skills to Develop\n`;
    formatted += skillsChecked.map((s: string) => `- ${s}`).join("\n") + "\n\n";
  }

  // Resources lacking
  if (resourcesChecked && resourcesChecked.length > 0) {
    formatted += `### Resource Gaps Identified\n`;
    formatted += resourcesChecked.map((r: string) => `- ${r}`).join("\n") + "\n\n";
  }

  // Success types
  if (successChecked && successChecked.length > 0) {
    formatted += `### Success Vision\n`;
    formatted += successChecked.map((s: string) => `- ${s}`).join("\n") + "\n\n";
  }

  // Persona
  if (persona) {
    formatted += `### User Persona\n`;
    formatted += `- ${persona}\n\n`;
  }

  return formatted;
}

function formatSummaryData(data: Record<string, any>): string {
  let formatted = "## Complete Transformation Data\n\n";

  // Combine all data sections
  if (data.purposeReflections) {
    formatted += formatPurposeData(data.purposeReflections);
  }

  if (data.analysisData) {
    formatted += formatFuturePathData(data.analysisData);
  }

  if (data.focusData) {
    formatted += `### Focus Clarification\n`;
    formatted += JSON.stringify(data.focusData, null, 2) + "\n\n";
  }

  return formatted;
}

// Main API handler
export function registerAiAnalysisRoutes(app: Express) {

  // Health check for AI service
  app.get("/api/ai-analyze/health", (req, res) => {
    const hasApiKey = !!process.env.ANTHROPIC_API_KEY;
    res.json({ 
      status: hasApiKey ? "ready" : "missing_api_key",
      message: hasApiKey ? "AI analysis service is ready" : "ANTHROPIC_API_KEY not configured"
    });
  });

  // Main analysis endpoint
  app.post("/api/ai-analyze", async (req, res) => {
    try {
      const { type, data, userId } = req.body as AnalysisRequest;

      // Validate request
      if (!type || !data) {
        return res.status(400).json({
          success: false,
          error: "Missing required fields: type and data"
        });
      }

      if (!systemPrompts[type]) {
        return res.status(400).json({
          success: false,
          error: `Invalid analysis type: ${type}. Valid types: ${Object.keys(systemPrompts).join(", ")}`
        });
      }

      // Check API key
      if (!process.env.ANTHROPIC_API_KEY) {
        return res.status(503).json({
          success: false,
          error: "AI service not configured. Please contact support."
        });
      }

      // Format data for the prompt
      const userContent = formatDataForPrompt(type, data);

      // Call Claude API
      const message = await anthropic.messages.create({
        model: "claude-sonnet-4-20250514",
        max_tokens: 4096,
        system: systemPrompts[type],
        messages: [
          {
            role: "user",
            content: userContent
          }
        ]
      });

      // Extract text response
      const textContent = message.content.find(block => block.type === "text");
      if (!textContent || textContent.type !== "text") {
        throw new Error("No text response from AI");
      }

      // Try to parse as JSON for structured response
      let structured: Record<string, any> | undefined;
      try {
        // Remove markdown code blocks if present
        let jsonText = textContent.text;
        if (jsonText.includes("```json")) {
          jsonText = jsonText.replace(/```json\n?/g, "").replace(/```\n?/g, "");
        } else if (jsonText.includes("```")) {
          jsonText = jsonText.replace(/```\n?/g, "");
        }
        structured = JSON.parse(jsonText.trim());
      } catch (e) {
        // If not valid JSON, that's okay - we'll return the raw text
        console.log("Response is not JSON, returning as text");
      }

      const response: AnalysisResponse = {
        success: true,
        analysis: textContent.text,
        structured
      };

      res.json(response);

    } catch (error: any) {
      console.error("AI Analysis error:", error);

      // Handle specific Anthropic errors
      if (error.status === 401) {
        return res.status(503).json({
          success: false,
          error: "AI service authentication failed. Please contact support."
        });
      }

      if (error.status === 429) {
        return res.status(429).json({
          success: false,
          error: "AI service is busy. Please try again in a moment."
        });
      }

      res.status(500).json({
        success: false,
        error: "Failed to generate analysis. Please try again."
      });
    }
  });
}